USE MASTER
GO
IF(OBJECT_ID('SP_GETUSEDOBJECTS')) IS NOT NULL
BEGIN
	DROP PROC SP_GETUSEDOBJECTS
END
GO
CREATE  PROCEDURE SP_GETUSEDOBJECTS 
@SQLTEXT	VARCHAR(MAX),
@EXECQUERY	BIT = 0,
@GETSTATS	BIT = 0,
@DBNAME		VARCHAR(100) = '',
@HELP		BIT = 0
AS

IF(@HELP <> 0)
BEGIN
PRINT 
'
>>>>>>>>>> EXEMPLOS DE CHAMADA DA PROCEDURE: <<<<<<<<<<<<<<<<


1 - BUSCANDO PLANO EM MEMÓRIA
SP_GETUSEDOBJECTS 
@HELP = 0,
@EXECQUERY = 0,
@GETSTATS = 0,
@SQLTEXT = "SELECT * FROM TABLE1 A INNER JOIN TABLE2 B ON A.ID = B.ID"

2 - EXECUTANDO A QUERY E CAPTURANDO PLANO ATUAL
SP_GETUSEDOBJECTS 
@HELP = 0,
@EXECQUERY = 1,
@GETSTATS = 0,
@SQLTEXT = "SELECT * FROM TABLE1 A INNER JOIN TABLE2 B ON A.ID = B.ID"

3 - EXECUTANDO A QUERY E CAPTURANDO ESTATISTICAS UTILIZADAS 
(WARNING) ESSA OPÇÃO PODE DEMORAR CONSIDERAVELMENTE COM BASE NOS DADOS EM CACHE
SP_GETUSEDOBJECTS 
@HELP = 0,
@EXECQUERY = 1,
@GETSTATS = 1,
@SQLTEXT = "SELECT * FROM TABLE1 A INNER JOIN TABLE2 B ON A.ID = B.ID"

4 - INFORMAÇÕES ADICIONAIS
SP_GETUSEDOBJECTS 
@HELP = 1,
@EXECQUERY = 0,
@GETSTATS = 0,
@SQLTEXT = "SELECT * FROM TABLE1 A INNER JOIN TABLE2 B ON A.ID = B.ID"



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
															SP_GETUSEDOBJECTS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Nome Procedure: SP_GETUSEDOBJECTS
Projeto.......: SCRIPTS
Versão........: 1.0.0.0
---------------------------------------------------------------------------------------------------------------------------------------------

SQL Server versões homologadas: SQL Server 2016 e 2017.
SQL Server versões testadas: SQL Server 2008 e superiores.

---------------------------------------------------------------------------------------------------------------------------------------------
Id		Autor                      Versão	      Data                            Descrição
---------------------------------------------------------------------------------------------------------------------------------------------

1		Reginaldo da Cruz Silva	   1.0.0.0		26/07/2017					Criação da procedure.


Créditos:
@Caio Amante.
Blog: https://caiosamante.wordpress.com/ 

---------------------------------------------------------------------------------------------------------------------------------------------

Revisão:
Reginaldo da Cruz Silva - 27/07/2017 18:00

Dúvidas e sugestões:
Blog: https://blogdojamal.wordpress.com/
Email: Reginaldo.silva27@gmail.com


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
												PARÂMETROS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PARÂMETRO									DESCRIÇÃO 
 
@HELP				- EXIBE DETALHES DE VERSÃO, ATUALIZAÇÃO, PARAMETRIZAÇÕES, ASSIM COMO EXEMPLOS DE CHAMADA.
@SQLTEXT			- TEXTO SQL QUE SERÁ PROCURADO NOS PLANOS DE EXECUÇÕES EM MEMÓRIA.
@EXECQUERY			- EXECUTA A QUERY DO PARAMÊTRO @SQLTEXT.
@GETSTATS			- (WARNING) ESSE PARAMÊTRO PODE DEGRADAR A PERFOMANCE DA EXECUÇÃO, ASSIM COMO A DO SERVIDOR DE SQL SERVER,
					  ESSE PARAMÊTRO TAMBÉM ATIVA O TRACE FLAG NÃO DOCUMENTADO (8666) PARA BUSCAR INFORMAÇÕES DAS ESTATISTICAS
					  PODENDO PREJUCAR A PERFORMANCE DO AMBIENTE DEPENDO DO TAMANHO DO CACHE DE DADOS(USE POR CONTA E RISCO).
@DBNAME				- BANCO DE DADOS QUE SERÁ CONSULTADO, PARAMETRO RECEBE UM VALOR DEFAULT DO BANCO QUE ORIGINOU A CHAMADA.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
										DESCRIÇÃO DAS COLUNAS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

   COLUNA											DESCRIÇÃO    

DBNAME							- NOME DA BASE DE DADOS EM USO
SCHEMANAME						- NOME DO SCHEMA DA TABELA UTILIZADA NA EXECUÇÃO
TABLENAME						- NOME DA TABELA UTILIZADA NA EXECUÇÃO
INDEXNAME						- NOME DO INDICE UTILIZADO NA EXECUÇÃO
STAT_NAME						- NOME DA ESTATISTICA UTILIZADA NO PLANO DE EXECUÇÃO
INDEX_TYPE						- TIPO DO INDICE, VALORES PARA ESSA COLUNA: CLUSTERED, NONCLUSTERED E HEAP
COLUMNS							- COLUNAS QUE PERTENCEM AO INDICE(ESTÃO EM TODOS OS NIVEIS DO INDICE)
INCLUDE_COLUMNS					- COLUNAS QUE PERTENCEM AO INDICE(ESTÃO APENAS NO NIVEL FOLHA DO INDICE)
UPDATE_COMMAND					- COMANDO PARA ATUALIZAR AS ESTATISCAS COM A OPÇÃO FULL SCAN
DROP_COMMAND					- COMANDO PARA EXCLUIR O INDICE
CREATE COMMAND					- COMANDO PARA CRIAR O INDICE

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

'
RETURN
END

SET @DBNAME = DB_NAME();

DECLARE @SQLTEXT_AUX VARCHAR(MAX)
IF(@EXECQUERY = 1 AND @GETSTATS = 1)
BEGIN
	SET @SQLTEXT_AUX = REPLACE(@SQLTEXT,'%','') 
	EXEC('DBCC TRACEON(8666,-1) ')
	EXEC(@SQLTEXT_AUX)
END
ELSE
IF(@EXECQUERY = 1)
BEGIN
	SET @SQLTEXT_AUX = REPLACE(@SQLTEXT,'%','')
	EXEC(@SQLTEXT_AUX);
END

IF(OBJECT_ID('TEMPDB..##TABLE')) IS NOT NULL
BEGIN
	DROP TABLE ##TABLE
END


CREATE TABLE ##TABLE (DBNAME VARCHAR(100),SCHEMANAME VARCHAR(100),TABLENAME VARCHAR(100), INDEXNAME VARCHAR(100))
DECLARE @XML VARCHAR(MAX),@DB VARCHAR(100),@SCHEMA VARCHAR(100), @TABLENAME VARCHAR(100), @INDEX VARCHAR(100)
DECLARE @CHARINI INT = 1, @CHARFIM INT = 0,@CHARAUX INT = 0

SELECT @XML = CAST(CP.query_plan AS VARCHAR(MAX))
FROM SYS.DM_EXEC_QUERY_STATS AS QS
CROSS APPLY SYS.DM_EXEC_SQL_TEXT(SQL_HANDLE)AS ST
CROSS APPLY SYS.DM_EXEC_QUERY_PLAN(PLAN_HANDLE) AS CP
WHERE ST.text = @SQLTEXT

WHILE @CHARINI <> 0
BEGIN

--DB
SET @CHARINI = CHARINDEX('Object Database="[',@XML,@CHARFIM)
IF(@CHARINI = 0)
	BREAK;

IF(@CHARINI <> 0)
BEGIN
	SET @CHARFIM = CHARINDEX(']',@XML,@CHARINI)
	SELECT @DB = SUBSTRING(@XML,@CHARINI + 18,@CHARFIM - @CHARINI - 18)
END

--SCHEMA
SET @CHARINI = CHARINDEX('Schema="[',@XML,@CHARFIM)
IF(@CHARINI <> 0)
BEGIN
	SET @CHARFIM = CHARINDEX(']',@XML,@CHARINI)
	SELECT @SCHEMA = SUBSTRING(@XML,@CHARINI + 9,@CHARFIM - @CHARINI - 9)
END

--TABLE
SET @CHARINI = CHARINDEX('Table="[',@XML,@CHARFIM)
IF(@CHARINI <> 0)
BEGIN
	SET @CHARFIM = CHARINDEX(']',@XML,@CHARINI)
	SELECT @TABLENAME = SUBSTRING(@XML,@CHARINI + 8,@CHARFIM - @CHARINI - 8)
END

--INDEX
SET @CHARAUX =CHARINDEX('/>',@XML,@CHARFIM)
SET @CHARINI = CHARINDEX('Index="[',@XML,@CHARFIM)

IF(((@CHARINI - @CHARFIM) > (@CHARAUX - @CHARFIM)) OR (@CHARINI - @CHARFIM) < 0)
BEGIN
	SET @CHARINI = CHARINDEX('IndexKind=',@XML,@CHARFIM)
	SET @CHARFIM = CHARINDEX('"',@XML,@CHARINI)
	SELECT @INDEX = SUBSTRING(@XML,@CHARINI + 11,@CHARFIM - @CHARINI - 6)
END
ELSE IF(@CHARINI <> 0)
BEGIN
	SET @CHARFIM = CHARINDEX(']',@XML,@CHARINI)
	SELECT @INDEX = SUBSTRING(@XML,@CHARINI + 8,@CHARFIM - @CHARINI - 8)
END


INSERT INTO ##TABLE VALUES(@DB,@SCHEMA,@TABLENAME,@INDEX)

END


DECLARE @RESULT TABLE(DBNAME VARCHAR(100),SCHEMANAME VARCHAR(100),TABLENAME VARCHAR(100), INDEXNAME VARCHAR(100), INDEX_TYPE VARCHAR(20), COLUMNS VARCHAR(1000),INCLUDE VARCHAR(1000), CREATE_COMAND VARCHAR(1000), DROP_COMAND VARCHAR(1000))

		INSERT INTO @RESULT
		EXEC('
		USE '+@DBNAME+'
		SELECT DISTINCT T.DBNAME,T.SCHEMANAME,T.TABLENAME,CASE WHEN  T.INDEXNAME = ''Heap'' THEN '''' ELSE T.INDEXNAME END,ISNULL(CR.TIPO,UPPER(T.INDEXNAME)) AS INDEX_TYPE,ISNULL(CR.CAMPOS,'''') AS FIELDS,ISNULL(CR.INCLUDE,'''') INCLUDE,CASE WHEN T.INDEXNAME = ''Heap'' THEN ''ALTER TABLE ''+T.TABLENAME+'' REBUILD'' ELSE ISNULL(CR.COMANDO_CRIACAO,'''') END AS CREATE_COMMAND,ISNULL(CR.COMANDO_DELECAO,'''') AS DROP_COMMAND
		FROM ##TABLE T 
		LEFT JOIN (

			SELECT	TABELA, INDICE, PRIMARY_KEY, INDICE_UNICO, UNIQUE_KEY, TIPO COLLATE SQL_Latin1_General_CP1_CI_AS TIPO, 
					SUBSTRING(CAMPOS,1,LEN(CAMPOS)-1)CAMPOS, SUBSTRING([INCLUDE],1,LEN([INCLUDE])-1)[INCLUDE], 
					
					CASE WHEN PRIMARY_KEY = 1 THEN ''ALTER TABLE ''+TABELA+'' ADD CONSTRAINT ''+INDICE+'' PRIMARY KEY ''+TIPO COLLATE SQL_Latin1_General_CP1_CI_AS +'' (''+SUBSTRING(CAMPOS,1,LEN(CAMPOS)-1)+'')''
						WHEN UNIQUE_KEY = 1 THEN ''ALTER TABLE ''+TABELA+'' ADD CONSTRAINT ''+INDICE+'' UNIQUE ''+TIPO COLLATE SQL_Latin1_General_CP1_CI_AS +'' (''+SUBSTRING(CAMPOS,1,LEN(CAMPOS)-1)+'')''
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDICE_UNICO = 1 THEN ''CREATE UNIQUE ''+TIPO COLLATE SQL_Latin1_General_CP1_CI_AS +'' INDEX ''+INDICE+ '' ON ''+TABELA+'' (''+SUBSTRING(CAMPOS,1,LEN(CAMPOS)-1)+'')''+ CASE WHEN [INCLUDE] IS NOT NULL THEN '' INCLUDE (''+SUBSTRING([INCLUDE],1,LEN([INCLUDE])-1)+'')'' ELSE '''' END
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDICE_UNICO = 0 THEN ''CREATE ''+TIPO COLLATE SQL_Latin1_General_CP1_CI_AS +'' INDEX ''+INDICE+ '' ON ''+TABELA+'' (''+SUBSTRING(CAMPOS,1,LEN(CAMPOS)-1)+'')''+ CASE WHEN [INCLUDE] IS NOT NULL THEN '' INCLUDE (''+SUBSTRING([INCLUDE],1,LEN([INCLUDE])-1)+'')'' ELSE '''' END END AS COMANDO_CRIACAO,
			
					CASE WHEN PRIMARY_KEY = 1 THEN ''ALTER TABLE ''+TABELA+'' DROP CONSTRAINT ''+INDICE
						WHEN UNIQUE_KEY = 1 THEN ''ALTER TABLE ''+TABELA+'' DROP CONSTRAINT ''+INDICE
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDICE_UNICO = 1 THEN ''DROP INDEX ''+INDICE+ '' ON ''+TABELA 
						WHEN PRIMARY_KEY = 0 AND UNIQUE_KEY = 0 AND INDICE_UNICO = 0 THEN ''DROP INDEX ''+INDICE+ '' ON ''+TABELA END AS COMANDO_DELECAO
			
			FROM(
			SELECT	TABELA, 
					INDICE,
					MAX(CAST(IS_PRIMARY_KEY AS INT))PRIMARY_KEY,
					MAX(CAST(IS_UNIQUE AS INT))INDICE_UNICO,
					MAX(CAST(IS_UNIQUE_CONSTRAINT AS INT))UNIQUE_KEY,
					MAX(TYPE_DESC) AS TIPO,
					
				(	SELECT CAMPO + '','' AS [text()]
					FROM (	SELECT	S.NAME AS TABELA, S6.NAME AS INDICE, S2.NAME AS CAMPO, S6.INDEX_COLUMN_ID AS ORDEM, S6.IS_INCLUDED_COLUMN AS INCLUD	
							FROM	[DBO].[SYSOBJECTS] S 
							INNER JOIN [DBO].[SYSCOLUMNS]		S2 ON S.ID = S2.ID
							INNER JOIN [DBO].[SYSTYPES]			S3 ON S2.XTYPE = S3.XTYPE AND S2.XUSERTYPE = S3.XUSERTYPE 
							INNER JOIN [SYS].[SCHEMAS]			S4 ON S.[UID] = S4.[SCHEMA_ID]
							LEFT  JOIN [SYS].[IDENTITY_COLUMNS]	S5 ON S2.ID = S5.[OBJECT_ID] AND S2.COLID = S5.COLUMN_ID
							LEFT  JOIN (SELECT S.[OBJECT_ID], S.NAME, S.TYPE_DESC, ISNULL(COLUMN_ID,0) AS COLUMN_ID, INDEX_COLUMN_ID, IS_INCLUDED_COLUMN
										FROM	[SYS].[INDEXES] S 
										INNER JOIN [SYS].[INDEX_COLUMNS] S2 ON S.[OBJECT_ID] = S2.[OBJECT_ID] AND S.INDEX_ID = S2.INDEX_ID
										)S6 ON S6.[OBJECT_ID] = S.ID AND S6.COLUMN_ID = S2.COLID
							WHERE S.XTYPE = ''U'' AND S4.NAME = ''DBO'' AND S6.COLUMN_ID <> 0 AND IS_INCLUDED_COLUMN = 0 
						)A 
					WHERE A.TABELA = B.TABELA AND A.INDICE = B.INDICE 
					ORDER BY TABELA,INDICE,ORDEM FOR XML PATH(''''))CAMPOS,
				
			
				(	SELECT CAMPO + '','' AS [text()]
					FROM (	SELECT	S.NAME AS TABELA, S6.NAME AS INDICE, S2.NAME AS CAMPO, S6.INDEX_COLUMN_ID AS ORDEM, S6.IS_INCLUDED_COLUMN AS INCLUD	
							FROM	[DBO].[SYSOBJECTS] S 
							INNER JOIN [DBO].[SYSCOLUMNS]		S2 ON S.ID = S2.ID
							INNER JOIN [DBO].[SYSTYPES]			S3 ON S2.XTYPE = S3.XTYPE AND S2.XUSERTYPE = S3.XUSERTYPE 
							INNER JOIN [SYS].[SCHEMAS]			S4 ON S.[UID] = S4.[SCHEMA_ID]
							LEFT  JOIN [SYS].[IDENTITY_COLUMNS]	S5 ON S2.ID = S5.[OBJECT_ID] AND S2.COLID = S5.COLUMN_ID
							LEFT  JOIN (SELECT S.[OBJECT_ID], S.NAME, S.TYPE_DESC, ISNULL(COLUMN_ID,0) AS COLUMN_ID, INDEX_COLUMN_ID, IS_INCLUDED_COLUMN
										FROM	[SYS].[INDEXES] S 
										INNER JOIN [SYS].[INDEX_COLUMNS] S2 ON S.[OBJECT_ID] = S2.[OBJECT_ID] AND S.INDEX_ID = S2.INDEX_ID
										)S6 ON S6.[OBJECT_ID] = S.ID AND S6.COLUMN_ID = S2.COLID
							WHERE S.XTYPE = ''U'' AND S4.NAME = ''DBO'' AND S6.COLUMN_ID <> 0 AND IS_INCLUDED_COLUMN <> 0 
						)A 
					WHERE A.TABELA = B.TABELA AND A.INDICE = B.INDICE 
					ORDER BY TABELA,INDICE,ORDEM FOR XML PATH(''''))[INCLUDE]
			
			FROM (
			SELECT S.NAME AS TABELA, S6.NAME AS INDICE, TYPE_DESC, IS_PRIMARY_KEY, IS_UNIQUE, IS_UNIQUE_CONSTRAINT, S2.NAME AS CAMPO, S6.INDEX_COLUMN_ID AS ORDEM, S6.IS_INCLUDED_COLUMN AS INCLUD
			FROM	[DBO].[SYSOBJECTS] S 
						INNER JOIN [DBO].[SYSCOLUMNS]		S2 ON S.ID = S2.ID
						INNER JOIN [DBO].[SYSTYPES]			S3 ON S2.XTYPE = S3.XTYPE AND S2.XUSERTYPE = S3.XUSERTYPE 
						INNER JOIN [SYS].[SCHEMAS]			S4 ON S.[UID] = S4.[SCHEMA_ID]
						LEFT  JOIN [SYS].[IDENTITY_COLUMNS]	S5 ON S2.ID = S5.[OBJECT_ID] AND S2.COLID = S5.COLUMN_ID
						LEFT  JOIN (SELECT S.[OBJECT_ID], S.NAME, S.TYPE_DESC, IS_PRIMARY_KEY, IS_UNIQUE, IS_UNIQUE_CONSTRAINT, ISNULL(COLUMN_ID,0) AS COLUMN_ID, INDEX_COLUMN_ID, IS_INCLUDED_COLUMN
									FROM	[SYS].[INDEXES] S 
											INNER JOIN [SYS].[INDEX_COLUMNS] S2 ON S.[OBJECT_ID] = S2.[OBJECT_ID] AND S.INDEX_ID = S2.INDEX_ID
									)S6 ON S6.[OBJECT_ID] = S.ID AND S6.COLUMN_ID = S2.COLID
				WHERE S.XTYPE = ''U'' AND S4.NAME = ''DBO'' AND S6.COLUMN_ID <> 0 
				
			)B
			GROUP BY TABELA, INDICE
			)CONSULTA 
		) CR ON T.TABLENAME = CR.TABELA AND T.INDEXNAME= CR.INDICE
		')


IF(@GETSTATS = 1)
BEGIN
	DECLARE @TABLE_STATS TABLE (TB_NAME VARCHAR(100), STATS_NAME VARCHAR(1000))
	DECLARE @TEXT VARCHAR(MAX) 

	SET @TEXT = '
	USE '+@DBNAME+'
	;WITH XMLNAMESPACES (''http://schemas.microsoft.com/sqlserver/2004/07/showplan'' as p)  
	SELECT OBJECT_NAME(S.OBJECT_ID) AS TABLE_NAME  ,StatsUsed.XMLCol.value(''@FieldValue'',''NVarChar(500)'') AS StatsName
	FROM sys.dm_exec_cached_plans cp  
	     CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) qp  
	     CROSS APPLY sys.dm_exec_sql_text (cp.plan_handle) qt  
	     CROSS APPLY query_plan.nodes(''//p:Field[@FieldName="wszStatName"]'') StatsUsed(XMLCol)  
	  LEFT JOIN SYS.STATS S ON S.name = StatsUsed.XMLCol.value(''@FieldValue'',''NVarChar(500)'')  
	   WHERE qt.text = '''+REPLACE(@SQLTEXT,'''','''''') +''' 
	   '

		INSERT INTO @TABLE_STATS
		EXEC (@TEXT)

		SELECT 
		DISTINCT T.DBNAME,T.SCHEMANAME,T.TABLENAME,T.INDEX_TYPE,T.INDEXNAME,ISNULL(TT.STATS_NAME,'') AS STATS_NAME,T.COLUMNS,T.INCLUDE,
		ISNULL('UPDATE STATISTICS '+T.SCHEMANAME+'.'+T.TABLENAME+' '+TT.STATS_NAME+' WITH FULLSCAN;','') UPDATE_COMAND,
		T.CREATE_COMAND,T.DROP_COMAND
		FROM @RESULT T 
		LEFT JOIN @TABLE_STATS TT ON T.TABLENAME = TT.TB_NAME
		ORDER BY T.TABLENAME

		EXEC('DBCC TRACEOFF(8666,-1)')
END 
ELSE
BEGIN

	SELECT * FROM @RESULT

END


DROP TABLE ##TABLE


